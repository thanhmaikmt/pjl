

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Connections &mdash; Brian v1.3.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Brian v1.3.0 documentation" href="index.html" />
    <link rel="up" title="Reference" href="reference.html" />
    <link rel="next" title="Plasticity" href="reference-plasticity.html" />
    <link rel="prev" title="Standard Groups" href="reference-standard-groups.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="reference-plasticity.html" title="Plasticity"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Brian v1.3.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="connections">
<h1>Connections<a class="headerlink" href="#connections" title="Permalink to this headline">¶</a></h1>
<p>The best way to understand the concept of a <a class="reference internal" href="#brian.Connection" title="brian.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> in
Brian is to work through Tutorial 2: Connections.</p>
<dl class="class">
<dt id="brian.Connection">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">Connection</tt><big>(</big><em>source</em>, <em>target</em>, <em>state=0</em>, <em>delay=0.0 s</em>, <em>modulation=None</em>, <em>structure='sparse'</em>, <em>weight=None</em>, <em>sparseness=None</em>, <em>max_delay=5.0 ms</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Mechanism for propagating spikes from one group to another</p>
<p>A Connection object declares that when spikes in a source
group are generated, certain neurons in the target group
should have a value added to specific states. See
Tutorial 2: Connections to understand this better.</p>
<p>With arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">source</span></tt></dt>
<dd>The group from which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">target</span></tt></dt>
<dd>The group to which spikes will be propagated.</dd>
<dt><tt class="docutils literal"><span class="pre">state</span></tt></dt>
<dd>The state variable name or number that spikes will be
propagated to in the target group.</dd>
<dt><tt class="docutils literal"><span class="pre">delay</span></tt></dt>
<dd>The delay between a spike being generated at the source
and received at the target. Depending on the type of <tt class="docutils literal"><span class="pre">delay</span></tt>
it has different effects. If <tt class="docutils literal"><span class="pre">delay</span></tt> is a scalar value, then
the connection will be initialised with all neurons having
that delay. For very long delays, this may raise an error. If
<tt class="docutils literal"><span class="pre">delay=True</span></tt> then the connection will be initialised as a
<a class="reference internal" href="#brian.DelayConnection" title="brian.DelayConnection"><tt class="xref py py-class docutils literal"><span class="pre">DelayConnection</span></tt></a>, allowing heterogeneous delays (a
different delay for each synapse). <tt class="docutils literal"><span class="pre">delay</span></tt> can also be a
pair <tt class="docutils literal"><span class="pre">(min,max)</span></tt> or a function of one or two variables, in
both cases it will be initialised as a <a class="reference internal" href="#brian.DelayConnection" title="brian.DelayConnection"><tt class="xref py py-class docutils literal"><span class="pre">DelayConnection</span></tt></a>,
see the documentation for that class for details. Note that in
these cases, initialisation of delays will only have the
intended effect if used with the <tt class="docutils literal"><span class="pre">weight</span></tt> and <tt class="docutils literal"><span class="pre">sparseness</span></tt>
arguments below.</dd>
<dt><tt class="docutils literal"><span class="pre">max_delay</span></tt></dt>
<dd>If you are using a connection with heterogeneous delays, specify
this to set the maximum allowed delay (smaller values use less
memory). The default is 5ms.</dd>
<dt><tt class="docutils literal"><span class="pre">modulation</span></tt></dt>
<dd>The state variable name from the source group that scales
the synaptic weights (for short-term synaptic plasticity).</dd>
<dt><tt class="docutils literal"><span class="pre">structure</span></tt></dt>
<dd>Data structure: <tt class="docutils literal"><span class="pre">sparse</span></tt> (default), <tt class="docutils literal"><span class="pre">dense</span></tt> or
<tt class="docutils literal"><span class="pre">dynamic</span></tt>. See below for more information on structures.</dd>
<dt><tt class="docutils literal"><span class="pre">weight</span></tt></dt>
<dd>If specified, the connection matrix will be initialised with
values specified by <tt class="docutils literal"><span class="pre">weight</span></tt>, which can be any of the values
allowed in the methods <cite>connect*`</cite> below.</dd>
<dt><tt class="docutils literal"><span class="pre">sparseness</span></tt></dt>
<dd>If <tt class="docutils literal"><span class="pre">weight</span></tt> is specified and <tt class="docutils literal"><span class="pre">sparseness</span></tt> is not, a full
connection is assumed, otherwise random connectivity with this
level of sparseness is assumed.</dd>
</dl>
<p><strong>Methods</strong></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">connect_random(P,Q,p[,weight=1[,fixed=False[,seed=None]]])</span></tt></dt>
<dd>Connects each neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to each neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with independent
probability <tt class="docutils literal"><span class="pre">p</span></tt> and weight <tt class="docutils literal"><span class="pre">weight</span></tt> (this is the amount that
gets added to the target state variable). If <tt class="docutils literal"><span class="pre">fixed</span></tt> is True, then
the number of presynaptic neurons per neuron is constant. If <tt class="docutils literal"><span class="pre">seed</span></tt>
is given, it is used as the seed to the random number generators, for
exactly repeatable results.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_full(P,Q[,weight=1])</span></tt></dt>
<dd>Connect every neuron in <tt class="docutils literal"><span class="pre">P</span></tt> to every neuron in <tt class="docutils literal"><span class="pre">Q</span></tt> with the given
weight.</dd>
<dt><tt class="docutils literal"><span class="pre">connect_one_to_one(P,Q)</span></tt></dt>
<dd>If <tt class="docutils literal"><span class="pre">P</span></tt> and <tt class="docutils literal"><span class="pre">Q</span></tt> have the same number of neurons then neuron <tt class="docutils literal"><span class="pre">i</span></tt>
in <tt class="docutils literal"><span class="pre">P</span></tt> will be connected to neuron <tt class="docutils literal"><span class="pre">i</span></tt> in <tt class="docutils literal"><span class="pre">Q</span></tt> with weight 1.</dd>
<dt><tt class="docutils literal"><span class="pre">connect(P,Q,W)</span></tt></dt>
<dd>You can specify a matrix of weights directly (can be in any format
recognised by NumPy). Note that due to internal implementation details,
passing a full matrix rather than a sparse one may slow down your code
(because zeros will be propagated as well as nonzero values).
<strong>WARNING:</strong> No unit checking is done at the moment.</dd>
</dl>
<p>Additionally, you can directly access the matrix of weights by writing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C</span> <span class="o">=</span> <span class="n">Connection</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
<span class="k">print</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Where here <tt class="docutils literal"><span class="pre">i</span></tt> is the source neuron and <tt class="docutils literal"><span class="pre">j</span></tt> is the target neuron.
Note: if <tt class="docutils literal"><span class="pre">C[i,j]</span></tt> should be zero, it is more efficient not to write
<tt class="docutils literal"><span class="pre">C[i,j]=0</span></tt>, if you write this then when neuron <tt class="docutils literal"><span class="pre">i</span></tt> fires all the
targets will have the value 0 added to them rather than just the
nonzero ones.
<strong>WARNING:</strong> No unit checking is currently done if you use this method.
Take care to set the right units.</p>
<p><strong>Connection matrix structures</strong></p>
<p>Brian currently features three types of connection matrix structures,
each of which is suited for different situations. Brian has two stages
of connection matrix. The first is the construction stage, used for
building a weight matrix. This stage is optimised for the construction
of matrices, with lots of features, but would be slow for runtime
behaviour. Consequently, the second stage is the connection stage,
used when Brian is being run. The connection stage is optimised for
run time behaviour, but many features which are useful for construction
are absent (e.g. the ability to add or remove synapses). Conversion
between construction and connection stages is done by the
<tt class="docutils literal"><span class="pre">compress()</span></tt> method of <a class="reference internal" href="#brian.Connection" title="brian.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> which is called
automatically when it is used for the first time.</p>
<p>The structures are:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">dense</span></tt></dt>
<dd>A dense matrix. Allows runtime modification of all values. If
connectivity is close to being dense this is probably the most
efficient, but in most cases it is less efficient. In addition,
a dense connection matrix will often do the wrong thing if
using STDP. Because a synapse will be considered to exist but
with weight 0, STDP will be able to create new synapses where
there were previously none. Memory requirements are <tt class="docutils literal"><span class="pre">8NM</span></tt>
bytes where <tt class="docutils literal"><span class="pre">(N,M)</span></tt> are the dimensions. (A <tt class="docutils literal"><span class="pre">double</span></tt> float
value uses 8 bytes.)</dd>
<dt><tt class="docutils literal"><span class="pre">sparse</span></tt></dt>
<dd>A sparse matrix. See <a class="reference internal" href="#brian.SparseConnectionMatrix" title="brian.SparseConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionMatrix</span></tt></a> for
details on implementation. This class features very fast row
access, and slower column access if the <tt class="docutils literal"><span class="pre">column_access=True</span></tt>
keyword is specified (making it suitable for learning
algorithms such as STDP which require this). Memory
requirements are 12 bytes per nonzero entry for row access
only, or 20 bytes per nonzero entry if column access is
specified. Synapses cannot be created or deleted at runtime
with this class (although weights can be set to zero).</dd>
<dt><tt class="docutils literal"><span class="pre">dynamic</span></tt></dt>
<dd>A sparse matrix which allows runtime insertion and removal
of synapses. See <a class="reference internal" href="#brian.DynamicConnectionMatrix" title="brian.DynamicConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">DynamicConnectionMatrix</span></tt></a> for
implementation details. This class features row and column
access. The row access is slower than for <tt class="docutils literal"><span class="pre">sparse</span></tt> so this
class should only be used when insertion and removal of
synapses is crucial. Memory requirements are 24 bytes per
nonzero entry. However, note that more memory than this
may be required because memory is allocated using a
dynamic array which grows by doubling its size when it runs
out. If you know the maximum number of nonzero entries you will
have in advance, specify the <tt class="docutils literal"><span class="pre">nnzmax</span></tt> keyword to set the
initial size of the array.</dd>
</dl>
<p><strong>Advanced information</strong></p>
<p>The following methods are also defined and used internally, if you are
writing your own derived connection class you need to understand what
these do.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">propagate(spikes)</span></tt></dt>
<dd>Action to take when source neurons with indices in <tt class="docutils literal"><span class="pre">spikes</span></tt>
fired.</dd>
<dt><tt class="docutils literal"><span class="pre">do_propagate()</span></tt></dt>
<dd>The method called by the <a class="reference internal" href="reference-network.html#brian.Network" title="brian.Network"><tt class="xref py py-class docutils literal"><span class="pre">Network</span></tt></a> <tt class="docutils literal"><span class="pre">update()</span></tt> step,
typically just propagates the spikes obtained by calling
the <tt class="docutils literal"><span class="pre">get_spikes</span></tt> method of the <tt class="docutils literal"><span class="pre">source</span></tt> <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="brian.DelayConnection">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DelayConnection</tt><big>(</big><em>source</em>, <em>target</em>, <em>state=0</em>, <em>modulation=None</em>, <em>structure='sparse'</em>, <em>weight=None</em>, <em>sparseness=None</em>, <em>delay=None</em>, <em>max_delay=5.0 ms</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DelayConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection which implements heterogeneous postsynaptic delays</p>
<p>Initialised as for a <a class="reference internal" href="#brian.Connection" title="brian.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>, but with the additional
keyword:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">max_delay</span></tt></dt>
<dd>Specifies the maximum delay time for any
neuron. Note, the smaller you make this the less memory will be
used.</dd>
</dl>
<p>Overrides the following attribute of <a class="reference internal" href="#brian.Connection" title="brian.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>:</p>
<dl class="attribute">
<dt id="brian.DelayConnection.delay">
<tt class="descname">delay</tt><a class="headerlink" href="#brian.DelayConnection.delay" title="Permalink to this definition">¶</a></dt>
<dd><p>A matrix of delays. This array can be changed during a run,
but at no point should it be greater than <tt class="docutils literal"><span class="pre">max_delay</span></tt>.</p>
</dd></dl>

<p>In addition, the methods <tt class="docutils literal"><span class="pre">connect</span></tt>, <tt class="docutils literal"><span class="pre">connect_random</span></tt>, <tt class="docutils literal"><span class="pre">connect_full</span></tt>,
and <tt class="docutils literal"><span class="pre">connect_one_to_one</span></tt> have a new keyword <tt class="docutils literal"><span class="pre">delay=...</span></tt> for setting the
initial values of the delays, where <tt class="docutils literal"><span class="pre">delay</span></tt> can be one of:</p>
<ul class="simple">
<li>A float, all delays will be set to this value</li>
<li>A pair (min, max), delays will be uniform between these two
values.</li>
<li>A function of no arguments, will be called for each nonzero
entry in the weight matrix.</li>
<li>A function of two argument <tt class="docutils literal"><span class="pre">(i,j)</span></tt> will be called for each
nonzero entry in the weight matrix.</li>
<li>A matrix of an appropriate type (e.g. ndarray or lil_matrix).</li>
</ul>
<p>Finally, there is a method:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">set_delays(source,</span> <span class="pre">target,</span> <span class="pre">delay)</span></tt></dt>
<dd>Where <tt class="docutils literal"><span class="pre">delay</span></tt> must be of one of the types above.</dd>
</dl>
<p><strong>Notes</strong></p>
<p>This class implements post-synaptic delays. This means that the spike is
propagated immediately from the presynaptic neuron with the synaptic
weight at the time of the spike, but arrives at the postsynaptic neuron
with the given delay. At the moment, Brian only provides support for
presynaptic delays if they are homogeneous, using the <tt class="docutils literal"><span class="pre">delay</span></tt> keyword
of a standard <tt class="docutils literal"><span class="pre">Connection</span></tt>.</p>
<p><strong>Implementation</strong></p>
<p><a class="reference internal" href="#brian.DelayConnection" title="brian.DelayConnection"><tt class="xref py py-class docutils literal"><span class="pre">DelayConnection</span></tt></a> stores an array of size <tt class="docutils literal"><span class="pre">(n,m)</span></tt> where
<tt class="docutils literal"><span class="pre">n</span></tt> is <tt class="docutils literal"><span class="pre">max_delay/dt</span></tt> for <tt class="docutils literal"><span class="pre">dt</span></tt> of the target <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a>&#8216;s clock,
and <tt class="docutils literal"><span class="pre">m</span></tt> is the number of neurons in the target. This array can potentially
be quite large. Each row in this array represents the array that should be
added to the target state variable at some particular future time. Which
row corresponds to which time is tracked using a circular indexing scheme.</p>
<p>When a spike from neuron <tt class="docutils literal"><span class="pre">i</span></tt> in the source is encountered, the delay time
of neuron <tt class="docutils literal"><span class="pre">i</span></tt> is looked up, the row corresponding to the current time
plus that delay time is found using the circular indexing scheme, and then
the spike is propagated to that row as for a standard connection (although
this won&#8217;t be propagated to the target until a later time).</p>
<p><strong>Warning</strong></p>
<p>If you are using a dynamic connection matrix, it is your responsibility to
ensure that the nonzero entries of the weight matrix and the delay matrix
exactly coincide. This is not an issue for sparse or dense matrices.</p>
</dd></dl>

<dl class="class">
<dt id="brian.IdentityConnection">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">IdentityConnection</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.IdentityConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#brian.Connection" title="brian.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> between two groups of the same size, where neuron <tt class="docutils literal"><span class="pre">i</span></tt> in the
source group is connected to neuron <tt class="docutils literal"><span class="pre">i</span></tt> in the target group.</p>
<p>Initialised with arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">source</span></tt>, <tt class="docutils literal"><span class="pre">target</span></tt></dt>
<dd>The source and target <a class="reference internal" href="reference-models-and-groups.html#brian.NeuronGroup" title="brian.NeuronGroup"><tt class="xref py py-class docutils literal"><span class="pre">NeuronGroup</span></tt></a> objects.</dd>
<dt><tt class="docutils literal"><span class="pre">state</span></tt></dt>
<dd>The target state variable.</dd>
<dt><tt class="docutils literal"><span class="pre">weight</span></tt></dt>
<dd>The weight of the synapse, must be a scalar.</dd>
<dt><tt class="docutils literal"><span class="pre">delay</span></tt></dt>
<dd>Only homogeneous delays are allowed.</dd>
</dl>
<p>The benefit of this class is that it has no storage requirements and is optimised for
this special case.</p>
</dd></dl>

<div class="section" id="connection-matrix-types">
<span id="index-0"></span><h2>Connection matrix types<a class="headerlink" href="#connection-matrix-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConnectionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">ConnectionMatrix</tt><a class="headerlink" href="#brian.ConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for connection matrix objects</p>
<p>Connection matrix objects support a subset of the following methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">get_row(i)</span></tt>, <tt class="docutils literal"><span class="pre">get_col(i)</span></tt></dt>
<dd>Returns row/col <tt class="docutils literal"><span class="pre">i</span></tt> as a <a class="reference internal" href="#brian.DenseConnectionVector" title="brian.DenseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">DenseConnectionVector</span></tt></a> or
<a class="reference internal" href="#brian.SparseConnectionVector" title="brian.SparseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> as appropriate for the class.</dd>
<dt><tt class="docutils literal"><span class="pre">set_row(i,</span> <span class="pre">val)</span></tt>, <tt class="docutils literal"><span class="pre">set_col(i,</span> <span class="pre">val)</span></tt></dt>
<dd>Sets row/col with an array, <a class="reference internal" href="#brian.DenseConnectionVector" title="brian.DenseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">DenseConnectionVector</span></tt></a> or
<a class="reference internal" href="#brian.SparseConnectionVector" title="brian.SparseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> (if supported).</dd>
<dt><tt class="docutils literal"><span class="pre">get_element(i,</span> <span class="pre">j)</span></tt>, <tt class="docutils literal"><span class="pre">set_element(i,</span> <span class="pre">j,</span> <span class="pre">val)</span></tt></dt>
<dd>Gets or sets a single value.</dd>
<dt><tt class="docutils literal"><span class="pre">get_rows(rows)</span></tt></dt>
<dd>Returns a list of rows, should be implemented without Python
function calls for efficiency if possible.</dd>
<dt><tt class="docutils literal"><span class="pre">get_cols(cols)</span></tt></dt>
<dd>Returns a list of cols, should be implemented without Python
function calls for efficiency if possible.</dd>
<dt><tt class="docutils literal"><span class="pre">insert(i,j,x)</span></tt>, <tt class="docutils literal"><span class="pre">remove(i,j)</span></tt></dt>
<dd>For sparse connection matrices which support it, insert a new
entry or remove an existing one.</dd>
<dt><tt class="docutils literal"><span class="pre">getnnz()</span></tt></dt>
<dd>Return the number of nonzero entries.</dd>
<dt><tt class="docutils literal"><span class="pre">todense()</span></tt></dt>
<dd>Return the matrix as a dense array.</dd>
</dl>
<p>The <tt class="docutils literal"><span class="pre">__getitem__</span></tt> and <tt class="docutils literal"><span class="pre">__setitem__</span></tt> methods are implemented by
default, and automatically select the appropriate methods from the
above in the cases where the item to be got or set is of the form
<tt class="docutils literal"><span class="pre">:</span></tt>, <tt class="docutils literal"><span class="pre">i,:</span></tt>, <tt class="docutils literal"><span class="pre">:,j</span></tt> or <tt class="docutils literal"><span class="pre">i,j</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConnectionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DenseConnectionMatrix</tt><big>(</big><em>val</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DenseConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense connection matrix</p>
<p>See documentation for <a class="reference internal" href="#brian.ConnectionMatrix" title="brian.ConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This matrix implements a dense connection matrix. It is just
a numpy array. The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<tt class="xref py py-class docutils literal"><span class="pre">DenseConnectionVector`</span></tt> objects.</p>
</dd></dl>

<dl class="class">
<dt id="brian.SparseConnectionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">SparseConnectionMatrix</tt><big>(</big><em>val</em>, <em>column_access=True</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.SparseConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse connection matrix</p>
<p>See documentation for <a class="reference internal" href="#brian.ConnectionMatrix" title="brian.ConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This class implements a sparse matrix with a fixed number of nonzero
entries. Row access is very fast, and if the <tt class="docutils literal"><span class="pre">column_access</span></tt> keyword
is <tt class="xref docutils literal"><span class="pre">True</span></tt> then column access is also supported (but is not as fast
as row access).</p>
<p>The matrix should be initialised with a scipy sparse matrix.</p>
<p>The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<a class="reference internal" href="#brian.SparseConnectionVector" title="brian.SparseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> objects. In addition to the
usual slicing operations supported, <tt class="docutils literal"><span class="pre">M[:]=val</span></tt> is supported, where
<tt class="docutils literal"><span class="pre">val</span></tt> must be a scalar or an array of length <tt class="docutils literal"><span class="pre">nnz</span></tt>.</p>
<p>Implementation details:</p>
<p>The values are stored in an array <tt class="docutils literal"><span class="pre">alldata</span></tt> of length <tt class="docutils literal"><span class="pre">nnz</span></tt> (number
of nonzero entries). The slice <tt class="docutils literal"><span class="pre">alldata[rowind[i]:rowind[i+1]]</span></tt> gives
the values for row <tt class="docutils literal"><span class="pre">i</span></tt>. These slices are stored in the list <tt class="docutils literal"><span class="pre">rowdata</span></tt>
so that <tt class="docutils literal"><span class="pre">rowdata[i]</span></tt> is the data for row <tt class="docutils literal"><span class="pre">i</span></tt>. The array <tt class="docutils literal"><span class="pre">rowj[i]</span></tt>
gives the corresponding column <tt class="docutils literal"><span class="pre">j</span></tt> indices. For row access, the
memory requirements are 12 bytes per entry (8 bytes for the float value,
and 4 bytes for the column indices). The array <tt class="docutils literal"><span class="pre">allj</span></tt> of length <tt class="docutils literal"><span class="pre">nnz</span></tt>
gives the column <tt class="docutils literal"><span class="pre">j</span></tt> coordinates for each element in <tt class="docutils literal"><span class="pre">alldata</span></tt> (the
elements of <tt class="docutils literal"><span class="pre">rowj</span></tt> are slices of this array so no extra memory is
used).</p>
<p>If column access is being used, then in addition to the above there are
lists <tt class="docutils literal"><span class="pre">coli</span></tt> and <tt class="docutils literal"><span class="pre">coldataindices</span></tt>. For column <tt class="docutils literal"><span class="pre">j</span></tt>, the array
<tt class="docutils literal"><span class="pre">coli[j]</span></tt> gives the row indices for the data values in column <tt class="docutils literal"><span class="pre">j</span></tt>,
while <tt class="docutils literal"><span class="pre">coldataindices[j]</span></tt> gives the indices in the array <tt class="docutils literal"><span class="pre">alldata</span></tt>
for the values in column <tt class="docutils literal"><span class="pre">j</span></tt>. Column access therefore involves a
copy operation rather than a slice operation. Column access increases
the memory requirements to 20 bytes per entry (4 extra bytes for the
row indices and 4 extra bytes for the data indices).</p>
</dd></dl>

<dl class="class">
<dt id="brian.DynamicConnectionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DynamicConnectionMatrix</tt><big>(</big><em>val</em>, <em>nnzmax=None</em>, <em>dynamic_array_const=2</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DynamicConnectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic (sparse) connection matrix</p>
<p>See documentation for <a class="reference internal" href="#brian.ConnectionMatrix" title="brian.ConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionMatrix</span></tt></a> for details on
connection matrix types.</p>
<p>This class implements a sparse matrix with a variable number of nonzero
entries. Row access and column access are provided, but are not as fast
as for <a class="reference internal" href="#brian.SparseConnectionMatrix" title="brian.SparseConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionMatrix</span></tt></a>.</p>
<p>The matrix should be initialised with a scipy sparse matrix.</p>
<p>The <tt class="docutils literal"><span class="pre">get_row</span></tt> and <tt class="docutils literal"><span class="pre">get_col</span></tt> methods return
<a class="reference internal" href="#brian.SparseConnectionVector" title="brian.SparseConnectionVector"><tt class="xref py py-class docutils literal"><span class="pre">SparseConnectionVector</span></tt></a> objects. In addition to the
usual slicing operations supported, <tt class="docutils literal"><span class="pre">M[:]=val</span></tt> is supported, where
<tt class="docutils literal"><span class="pre">val</span></tt> must be a scalar or an array of length <tt class="docutils literal"><span class="pre">nnz</span></tt>.</p>
<p><strong>Implementation details</strong></p>
<p>The values are stored in an array <tt class="docutils literal"><span class="pre">alldata</span></tt> of length <tt class="docutils literal"><span class="pre">nnzmax</span></tt> (maximum
number of nonzero entries). This is a dynamic array, see:</p>
<blockquote>
<div><a class="reference external" href="http://en.wikipedia.org/wiki/Dynamic_array">http://en.wikipedia.org/wiki/Dynamic_array</a></div></blockquote>
<p>You can set the resizing constant with the argument <tt class="docutils literal"><span class="pre">dynamic_array_const</span></tt>.
Normally the default value 2 is fine but if memory is a worry it could be
made smaller.</p>
<p>Rows and column point in to this data array, and the list <tt class="docutils literal"><span class="pre">rowj</span></tt> consists
of an array of column indices for each row, with <tt class="docutils literal"><span class="pre">coli</span></tt> containing arrays
of row indices for each column. Similarly, <tt class="docutils literal"><span class="pre">rowdataind</span></tt> and <tt class="docutils literal"><span class="pre">coldataind</span></tt>
consist of arrays of pointers to the indices in the <tt class="docutils literal"><span class="pre">alldata</span></tt> array.</p>
</dd></dl>

</div>
<div class="section" id="construction-matrix-types">
<h2>Construction matrix types<a class="headerlink" href="#construction-matrix-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConstructionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">ConstructionMatrix</tt><a class="headerlink" href="#brian.ConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for construction matrices</p>
<p>A construction matrix is used to initialise and build connection matrices.
A <tt class="docutils literal"><span class="pre">ConstructionMatrix</span></tt> class has to implement a method
<tt class="docutils literal"><span class="pre">connection_matrix(*args,</span> <span class="pre">**kwds)</span></tt> which returns a <a class="reference internal" href="#brian.ConnectionMatrix" title="brian.ConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionMatrix</span></tt></a>
object of the appropriate type.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConstructionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DenseConstructionMatrix</tt><big>(</big><em>val</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DenseConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense construction matrix. Essentially just numpy.ndarray.</p>
<p>The <tt class="docutils literal"><span class="pre">connection_matrix</span></tt> method returns a <a class="reference internal" href="#brian.DenseConnectionMatrix" title="brian.DenseConnectionMatrix"><tt class="xref py py-class docutils literal"><span class="pre">DenseConnectionMatrix</span></tt></a>
object.</p>
<p>The <tt class="docutils literal"><span class="pre">__setitem__</span></tt> method is overloaded so that you can set values with
a sparse matrix.</p>
</dd></dl>

<dl class="class">
<dt id="brian.SparseConstructionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">SparseConstructionMatrix</tt><big>(</big><em>arg</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.SparseConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>SparseConstructionMatrix is converted to SparseConnectionMatrix.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DynamicConstructionMatrix">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DynamicConstructionMatrix</tt><big>(</big><em>arg</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#brian.DynamicConstructionMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>DynamicConstructionMatrix is converted to DynamicConnectionMatrix.</p>
</dd></dl>

</div>
<div class="section" id="connection-vector-types">
<h2>Connection vector types<a class="headerlink" href="#connection-vector-types" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="brian.ConnectionVector">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">ConnectionVector</tt><a class="headerlink" href="#brian.ConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for connection vectors, just used for defining the interface</p>
<p>ConnectionVector objects are returned by ConnectionMatrix objects when
they retrieve rows or columns. At the moment, there are two choices,
sparse or dense.</p>
<p>This class has no real function at the moment.</p>
</dd></dl>

<dl class="class">
<dt id="brian.DenseConnectionVector">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">DenseConnectionVector</tt><a class="headerlink" href="#brian.DenseConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Just a numpy array.</p>
</dd></dl>

<dl class="class">
<dt id="brian.SparseConnectionVector">
<em class="property">class </em><tt class="descclassname">brian.</tt><tt class="descname">SparseConnectionVector</tt><a class="headerlink" href="#brian.SparseConnectionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse vector class</p>
<p>A sparse vector is typically a row or column of a sparse matrix. This
class can be treated in many cases as if it were just a vector without
worrying about the fact that it is sparse. For example, if you write
<tt class="docutils literal"><span class="pre">2*v</span></tt> it will evaluate to a new sparse vector. There is one aspect
of the semantics which is potentially confusing. In a binary operation
with a dense vector such as <tt class="docutils literal"><span class="pre">sv+dv</span></tt> where <tt class="docutils literal"><span class="pre">sv</span></tt> is sparse and <tt class="docutils literal"><span class="pre">dv</span></tt>
is dense, the result will be a sparse vector with zeros where <tt class="docutils literal"><span class="pre">sv</span></tt>
has zeros, the potentially nonzero elements of <tt class="docutils literal"><span class="pre">dv</span></tt> where <tt class="docutils literal"><span class="pre">sv</span></tt> has
no entry will be simply ignored. It is for this reason that it is a
<tt class="docutils literal"><span class="pre">SparseConnectionVector</span></tt> and not a general <tt class="docutils literal"><span class="pre">SparseVector</span></tt>, because
these semantics make sense for rows and columns of connection matrices
but not in general.</p>
<p>Implementation details:</p>
<p>The underlying numpy array contains the values, the attribute <tt class="docutils literal"><span class="pre">n</span></tt> is
the length of the sparse vector, and <tt class="docutils literal"><span class="pre">ind</span></tt> is an array of the indices
of the nonzero elements.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/brian-logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Connections</a><ul>
<li><a class="reference internal" href="#connection-matrix-types">Connection matrix types</a></li>
<li><a class="reference internal" href="#construction-matrix-types">Construction matrix types</a></li>
<li><a class="reference internal" href="#connection-vector-types">Connection vector types</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="reference-standard-groups.html"
                        title="previous chapter">Standard Groups</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="reference-plasticity.html"
                        title="next chapter">Plasticity</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/reference-connections.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="reference-plasticity.html" title="Plasticity"
             >next</a> |</li>
        <li class="right" >
          <a href="reference-standard-groups.html" title="Standard Groups"
             >previous</a> |</li>
        <li><a href="index.html">Brian v1.3.0 documentation</a> &raquo;</li>
          <li><a href="reference.html" >Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, Romain Brette, Dan Goodman.
      Last updated on Feb 18, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>